---
sidebar_label: Analysis of Loops
---

# Analysis of Loops

<!--- Import Component Here --->

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<!--- Content - Start --->

## DÃ¶ngÃ¼ler AlgoritmalarÄ±n KarmaÅŸÄ±klÄ±k Analizinde NasÄ±l Analiz Edilir?

Ã–nceki yazÄ±larÄ±mÄ±zda [Asymptotic Analysis](https://cs-space.vercel.app/algorithms/analysis-of-algorithms/asymptotic-analysis), [Worst, Average and Best Cases](https://cs-space.vercel.app/algorithms/analysis-of-algorithms/worst-average-and-best-cases) ve [Asymptotic Notations](https://cs-space.vercel.app/algorithms/analysis-of-algorithms/asymptotic-notations) konularÄ±nÄ± tartÄ±ÅŸmÄ±ÅŸtÄ±k. Bu yazÄ±da yinelemeli programlarÄ±n analizini basit bir Ã¶rnekle konuÅŸacaÄŸÄ±z.

### ğŸ‘‰ Sabit Zaman KarmaÅŸÄ±klÄ±ÄŸÄ± (Constant Time Complexity) O(1)

EÄŸer bir fonksiyon dÃ¶ngÃ¼, Ã¶zyineleme (recursion) ve baÅŸka herhangi bir sabit olmayan zamanlÄ± fonksiyon Ã§aÄŸÄ±rÄ±sÄ± iÃ§ermiyorsa o fonksiyonun veya durumun zaman karmaÅŸÄ±klÄ±ÄŸÄ± (time complexity) O(1) olarak kabul edilir. Yani, **sabit zaman karmaÅŸÄ±klÄ±ÄŸÄ±** Ã¶zyineleme ve dÃ¶ngÃ¼ iÃ§ermeyen ifadelerdir.

:::note Ã–rnek

<details>
  <summary>swap() fonksiyonu O(1) zaman karmaÅŸÄ±klÄ±ÄŸÄ±na sahiptir.</summary>
  <div>
    <h4>Ä°ki SayÄ±yÄ± KarÅŸÄ±lÄ±klÄ± DeÄŸiÅŸtiren (Swap) C ProgramÄ±</h4>

     Girdi: x = 10, y = 20
     Ã‡Ä±ktÄ±: x = 20, y = 10

     Girdi: x = 200, y = 100
     Ã‡Ä±ktÄ±: x = 100, y = 200

  </div>
<Image copyRight="Fire Ocean">

![Swap Function](../images/06-analysis-of-loops.png)

</Image>

<b>
  Soru Ã§Ã¶zÃ¼mÃ¼nden Ã¶nce lÃ¼tfen â€œ
  <a href="https://practice.geeksforgeeks.org/problems/swap-two-numbers/0">
    <i>PRATÄ°K</i>
  </a>
  â€ yaparak kendinizi deneyin.
</b>
<br />
<br />
AmaÃ§ Ã§ok basit:{' '}

<ol>
  <li>
    GeÃ§ici bir deÄŸiÅŸkene xâ€™i atamak: <b>temp = x</b>
  </li>
  <li>
    xâ€™e yâ€™i atamak: <b>x = y</b>
  </li>
  <li>
    yâ€™ye geÃ§ici deÄŸiÅŸkeni atamak: <b>temp = y</b>
  </li>
</ol>

<u>Bir Ã¶rnekle bunu daha iyi Ã¶ÄŸrenelim</u>

<br />
<br />

    x = 100, y = 200

    Ä°lk satÄ±rdan sonra: temp = x â†’ temp = 100
    Ä°kinci satÄ±rdan sonra: x = y â†’ x = 200
    ÃœÃ§Ã¼ncÃ¼ satÄ±rdan sonra: y = temp â†’ y = 100

```jsx
// C programlama dilinde iki deÄŸiÅŸkenin deÄŸerlerini deÄŸiÅŸ tokuÅŸ etmek

#include

int main()
{
    int x, y;

    printf("x iÃ§in bir deÄŸer girin: ");
    scanf("%d", &x);

    printf("\ny iÃ§in bir deÄŸer girin: ");
    scanf("%d", &y);

    int temp = x;

    x = y;
    y = temp;

    printf("\nDeÄŸiÅŸtirdikten Sonra: x = %d, y = %d", x, y);

    return 0;
}
```

<b>Ã‡Ä±ktÄ±</b>

```
x iÃ§in bir deÄŸer girin: 12

y iÃ§in bir deÄŸer girin: 14

DeÄŸiÅŸtirdikten sonra: x = 14, y = 12
```

<b>Zaman KarmaÅŸÄ±klÄ±ÄŸÄ±:</b> O(1)
<br />
<b>Alan KarmaÅŸÄ±klÄ±ÄŸÄ±:</b> O(1)

</details>

<details>
  <summary>Bir dÃ¶ngÃ¼ ya da Ã¶zyineleme de sabit sayÄ±da Ã§alÄ±ÅŸÄ±yorsa O(1) olarak kabul edilir. Ã–rneÄŸin aÅŸaÄŸÄ±daki dÃ¶ngÃ¼nÃ¼n zaman karmaÅŸÄ±klÄ±ÄŸÄ± O(1)â€™dir.</summary>

```jsx
// c deÄŸiÅŸkeni sabittir.

for (int i = 1; i <= c; i++) {
  //bazÄ± O(1) ifadeleri
}
```

</details>
:::

### ğŸ‘‰ Linear Zaman KarmaÅŸÄ±klÄ±ÄŸÄ± (Linear Time Complexity) O(n)

EÄŸer bir dÃ¶ngÃ¼nÃ¼n deÄŸiÅŸkenleri sabit bir miktarda azaltÄ±lmÄ±ÅŸsa ya da arttÄ±rÄ±lmÄ±ÅŸsa bu dÃ¶ngÃ¼nÃ¼n zaman karmaÅŸÄ±klÄ±ÄŸÄ±nÄ± O(n) olarak kabul ederiz. AÅŸaÄŸÄ±da yer alan Ã¶rnekteki fonksiyonlar O(n) zaman karmaÅŸÄ±klÄ±ÄŸÄ±na sahiptir.

```jsx
//c deÄŸiÅŸkeni sabit bir pozitif tamsayÄ±dÄ±r (sabit = miktarÄ± deÄŸiÅŸmeyen)

for (int i = 1; i <= n; i += c) {
	  //bazÄ± O(1) ifadeleri
}

for (int i = n; i > 0; i -= c) {
	  //bazÄ± O(1) ifadeleri
}
```

### ğŸ‘‰ Quadratic Zaman KarmaÅŸÄ±klÄ±ÄŸÄ± (Quadratic Time Complexity) O(n^c)

Quadratic zaman karmaÅŸÄ±klÄ±ÄŸÄ± performansÄ± giriÅŸ deÄŸerlerinin karesiyle doÄŸru orantÄ±lÄ± olan bir algoritma olarak tanÄ±mlanÄ±r. Ã‡Ã¼nkÃ¼ bu tarz algoritma Ã¶rneklerinde bir linear iÅŸlemin iÃ§erisinde baÅŸka bir linear iÅŸlem Ã§alÄ±ÅŸtÄ±rÄ±lmaktadÄ±r (n\*n = n<sup>2</sup>). Ã–rneÄŸin, aÅŸaÄŸÄ±daki Ã¶rnekteki dÃ¶ngÃ¼nÃ¼n zaman karmaÅŸÄ±klÄ±ÄŸÄ± O(n^2)â€™dir.

```jsx
for (int i = 1; i <= n; i += c) {
    for (int j = 1; j <= n; j += c) {
        //bazÄ± O(1) ifadeleri
    }
}

for (int i = n; i > 0; i -= c) {
    for (int j = i + 1; j <= n; j += c) {
        //bazÄ± O(1) ifadeleri
    }
}
```

:::note Ã–rnek
[Selection Sort](https://cs-space.vercel.app/algorithms/sorting-algorithms/selection-sort) ve [Insertion Sort](https://cs-space.vercel.app/algorithms/sorting-algorithms/insertion-sort) algoritmalarÄ±nÄ±n zaman karmaÅŸÄ±klÄ±ÄŸÄ± O(n^2)â€™dir.
:::

### ğŸ‘‰ Logaritmik Zaman KarmaÅŸÄ±klÄ±ÄŸÄ± (Logarithmic Time Complexity) O(Logn)

EÄŸer bir dÃ¶ngÃ¼ deÄŸiÅŸkenleri sabit bir miktarda Ã§arpÄ±lmÄ±ÅŸ ya da bÃ¶lÃ¼nmÃ¼ÅŸse bu dÃ¶ngÃ¼nÃ¼n zaman karmaÅŸÄ±klÄ±ÄŸÄ± O(Logn) olarak kabul edilir.

```jsx
for (int i = 1; i <= n; i *= c) {
    // bazÄ± O(1) ifadeleri
}
for (int i = n; i > 0; i /= c) {
    // bazÄ± O(1) ifadeleri
}
```

AyrÄ±ca Ã¶zyinelemeli fonksiyonlarda Ã¶zyinelemeli Ã§aÄŸrÄ±larÄ±n zaman karmaÅŸÄ±klÄ±ÄŸÄ± O(Logn) olarak kabul edilir.

```jsx
// Ã–zyinelemeli (recursive) fonksiyon

void recurse(n);
{
  if (n == 0) return;
  else {
    // bazÄ± O(1) ifadeleri
  }
  recurse(n - 1);
}
```

:::note Ã–rnek
[Binary Search](https://cs-space.vercel.app/algorithms/searching-algorithms/binary-search) algoritmasÄ±nÄ±n zaman karmaÅŸÄ±klÄ±ÄŸÄ± O(Logn)â€™dir.
:::

### ğŸ‘‰ Logaritmik Zaman KarmaÅŸÄ±klÄ±ÄŸÄ± (Logarithmic Time Complexity) O(Log Log n)

EÄŸer bir dÃ¶ngÃ¼nÃ¼n deÄŸiÅŸkenleri sabit bir zamanda katlanarak azalÄ±yorsa ya da artÄ±yorsa bu dÃ¶ngÃ¼nÃ¼n zaman karmaÅŸÄ±klÄ±ÄŸÄ± O(LogLogn) olarak kabul edilir.

```jsx
// Burada c girdisi 1â€™den daha bÃ¼yÃ¼k bir sabittir
for (int i = 2; i <= n; i = pow(i, c)) {
    // bazÄ± O(1) ifadeleri
}

// Burada fun bir kare kÃ¶k, kÃ¼p kÃ¶k veya sabit bir kÃ¶ktÃ¼r.
for (int i = n; i > 1; i = fun(i)) {
    // bazÄ± O(1) ifadeleri
}
```

### ğŸ’  Bir DÃ¶ngÃ¼ DeÄŸiÅŸkeninin Katlanarak â€œKÃ¼Ã§Ã¼lmesi ya da BÃ¼yÃ¼mesiâ€ nin Zaman KarmaÅŸÄ±klÄ±ÄŸÄ±nÄ±n Matematiksel DetayÄ±

Bu gibi durumlar iÃ§in bir dÃ¶ngÃ¼nÃ¼n zaman karmaÅŸÄ±klÄ±ÄŸÄ± O(log(log(n)))â€™dir. AÅŸaÄŸÄ±daki ele aldÄ±ÄŸÄ±mÄ±z problemin farklÄ± yÃ¶nlerini analiz eder.

**Durum 1**

```jsx
for (int i = 2; i <=n; i = pow(i, k))
{
    // bazÄ± O(1) ifadeleri veya durumlarÄ±
}
```

Bu durumda i deÄŸiÅŸkeni 2, 2<sup>k</sup>, (2<sup>k</sup>)<sup>k</sup>, (2<sup>k<sup>2</sup></sup>)<sup>k</sup> = 2<sup>k<sup>3</sup></sup>, ....2<sup>k<sup>log<sub>k</sub>(log(n))</sup></sup> deÄŸerlerini alÄ±r. En sonuncu ifade nâ€™den kÃ¼Ã§Ã¼k ya da nâ€™e eÅŸit olmalÄ± ve biz 2<sup>k<sup>log<sub>k</sub>(log(n))</sup></sup> = 2<sup>log(n)</sup> = n ifadesine sahibiz. Bu ifade son terimimizin deÄŸeriyle tamamen uyuÅŸuyor. BÃ¶ylece toplamda bir Ã§ok log<sub>k</sub>(log(n)) yineleme sÃ¶z konusu ve her bir yinelemenin Ã§alÄ±ÅŸmasÄ± sabit bir sÃ¼re alÄ±r. Bu nedenle toplam zaman karmaÅŸÄ±klÄ±ÄŸÄ± O(log(log(n)))â€™dir.

**Durum 2**

```jsx
// func() herhangi bir sabit kÃ¶k fonksiyonudur
for (int i = n; i > 1; i = func(i))
{
   // bazÄ± O(1) ifadeleri veya durumlarÄ±
}
```

Bu durumda i deÄŸiÅŸkeni n, n<sup>1/k</sup>, (n<sup>1/k</sup>)<sup>1/k</sup> = n<sup>1/k<sup>2</sup></sup>, n<sup>1/k<sup>3</sup></sup>, n<sup>1/k<sup>log<sub>k</sub><sup>(log(n))</sup></sup></sup> deÄŸerlerini alÄ±r. BÃ¶ylece toplamda log<sub>k</sub>(log(n)) yineleme var ve her bir yineleme O(1) zaman alÄ±r. BÃ¶ylece toplam zaman karmaÅŸÄ±klÄ±ÄŸÄ± O(log(log(n)))â€™dir.

### ğŸ’  ArdÄ±ÅŸÄ±k DÃ¶ngÃ¼lerin Zaman KarmaÅŸÄ±klÄ±ÄŸÄ± NasÄ±l BirleÅŸtirilir?

ArdÄ±ÅŸÄ±k dÃ¶ngÃ¼ler olduÄŸunda dÃ¶ngÃ¼lerin tek tek zaman karmaÅŸÄ±klÄ±klarÄ±nÄ±n toplamÄ±nÄ± hesaplarÄ±z.

```jsx
for (int i = 1; i <= m; i += c) {
    // bazÄ± O(1) ifadeleri
}

for (int i = 1; i <= n; i += c) {
    // bazÄ± O(1) ifadeleri
}
```

**Zaman KarmaÅŸÄ±klÄ±ÄŸÄ± ğŸ‘†**

<ul>
  <li>O(m) + O(n)</li>
  <li>daha da sadeleÅŸtirirsek â–¶ï¸ O(m + n)</li>
  <li>
    eÄŸer m === n ise â–¶ï¸ 2n olur. Bunun sonucunda O(n) olur. (KatsayÄ±larÄ± dikkate
    almayÄ±z.)
  </li>
</ul>

### ğŸ’  EÄŸer Bir DÃ¶ngÃ¼nÃ¼n Ä°Ã§inde Ã‡ok Fazla If-Else KoÅŸulu Varsa Zaman KarmaÅŸÄ±klÄ±ÄŸÄ± NasÄ±l HesaplanÄ±r?

[Bu yazÄ±da](https://cs-space.vercel.app/algorithms/analysis-of-algorithms/worst-average-and-best-cases) anlattÄ±ÄŸÄ±mÄ±z gibi en kÃ¶tÃ¼ durum zaman karmaÅŸÄ±klÄ±ÄŸÄ± ortalama (average) durum, en iyi (best) durum arasÄ±nda en Ã§ok kullanÄ±landÄ±r. Bu nedenle en kÃ¶tÃ¼ durumu kabul etmemiz gerekiyor. If-else koÅŸullarÄ±ndaki deÄŸerler ifadenin maksimum sayÄ±da yÃ¼rÃ¼tÃ¼lmesine neden olduÄŸu zamanlarda durumu deÄŸerlendiririz.

<u>Ã–rneÄŸin</u>; bir dizide bir elemanÄ±n sonuncu Ã¶ÄŸe olduÄŸunu ya da mevcut
olmadÄ±ÄŸÄ±nÄ± dikkate aldÄ±ÄŸÄ±mÄ±z linear search fonksiyonunu dÃ¼ÅŸÃ¼nelim. Kod tÃ¼m
if-else durumlarÄ±nÄ± dikkate alamayacak kadar karmaÅŸÄ±k olduÄŸunda if-else durumunu
ve diÄŸer karmaÅŸÄ±k kontrolleri gÃ¶rmezden gelerek bir Ã¼st sÄ±nÄ±r (upper-bound)
belirleyebiliriz.

### ğŸ’  Ã–zyinelemeli (Recursive) FonksiyonlarÄ±n Zaman KarmaÅŸÄ±klÄ±ÄŸÄ± NasÄ±l HesaplanÄ±r?

Bir Ã¶zyinelemeli fonksiyonun zaman karmaÅŸÄ±klÄ±ÄŸÄ± matematiksal bir yineleme iliÅŸkisi olarak yazÄ±labilir. Zaman karmaÅŸÄ±klÄ±ÄŸÄ±nÄ± hesaplamak iÃ§in yinelenmelerin nasÄ±l Ã§Ã¶zÃ¼leceÄŸini bilmemiz gerekir. Bu konuyu yinelenme Ã§Ã¶zÃ¼m teknikleri olarak baÅŸka bir yazÄ±da ele alacaÄŸÄ±z.

### ğŸ‘‰ Algoritmalar Ã–zet Tablosu

<!-- HTML Code: Place this code in the document's body (between the 'body' tags) where the table should appear -->

<table>
  <thead>
    <tr>
      <th>Algoritma</th>
      <th>En Ä°yi Durum</th>
      <th>Ortalama Durum</th>
      <th>En KÃ¶tÃ¼ Durum</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Selection Sort</td>
      <td>O(n^2)</td>
      <td>O(n^2)</td>
      <td>O(n^2)</td>
    </tr>
    <tr>
      <td>Bubble Sort</td>
      <td>O(n)</td>
      <td>O(n^2)</td>
      <td>O(n^2)</td>
    </tr>
    <tr>
      <td>Insertion Sort</td>
      <td>O(n)</td>
      <td>O(n^2)</td>
      <td>O(n^2)</td>
    </tr>
    <tr>
      <td>Tree Sort</td>
      <td>O(nlogn)</td>
      <td>O(nlogn)</td>
      <td>O(n^2)</td>
    </tr>
    <tr>
      <td>Radix Sort</td>
      <td>O(dn)</td>
      <td>O(dn)</td>
      <td>O(dn)</td>
    </tr>
    <tr>
      <td>Merge Sort</td>
      <td>O(nlogn)</td>
      <td>O(nlogn)</td>
      <td>O(nlogn)</td>
    </tr>
    <tr>
      <td>Heap Sort</td>
      <td>O(nlogn)</td>
      <td>O(nlogn)</td>
      <td>O(nlogn)</td>
    </tr>
    <tr>
      <td>Quick Sort</td>
      <td>O(nlogn)</td>
      <td>O(nlogn)</td>
      <td>O(n^2)</td>
    </tr>
    <tr>
      <td>Bucket Sort</td>
      <td>O(n+k)</td>
      <td>O(n+k)</td>
      <td>O(n^2)</td>
    </tr>
    <tr>
      <td>Counting Sort</td>
      <td>O(n+k)</td>
      <td>O(n+k)</td>
      <td>O(n+k)</td>
    </tr>
  </tbody>
</table>

<!--- Content - End --->

<!--- Links Source - Start --->

## Kaynaklar Baglantisi

:::info Kaynaklar BaÄŸlantÄ±sÄ±

<Tabs>
  <TabItem value="youtube-videos" label="Youtube videolarÄ±" default>
    <ul>
      <li>
        <a href="https://www.youtube.com/watch?v=uDSG-czh3F0">
          KarmaÅŸÄ±klÄ±k Analizi Ã–rnekleri
        </a>
      </li>
      <li>
        <a href="https://www.youtube.com/watch?v=wMp0BrWaoz8">
          Algoritma Analizi ve Big O (Time Complexity, Space Complexity)
        </a>
      </li>
      <li>
        <a href="https://www.youtube.com/watch?v=8MwDRZs1IBU&t=2s">
          Big O Notasyonu - Ã–rneklerle - Time Complexity
        </a>
      </li>
    </ul>
  </TabItem>
  <TabItem value="blog-article" label="Blog & Makale">
    <ul>
      <li>
        <a href="https://medium.com/kodcular/nedir-bu-big-o-notation-b8b9f1416d30">
          Nedir Bu "Big O Notation"?
        </a>
      </li>
    </ul>
  </TabItem>
  <TabItem value="questions" label="Sorular">
    <ul>
      <li>
        <a href="https://www.geeksforgeeks.org/algorithms-gq/analysis-of-algorithms-gq/">
          Analysis of Algorithms
        </a>
      </li>
      <li>
        <a href="https://study.com/academy/practice/quiz-worksheet-analyzing-algorithms.html">
          What Is Algorithm Analysis? - Methods & Types - Quiz & Worksheet
        </a>
      </li>
    </ul>
  </TabItem>
</Tabs>

:::

<!--- Links Source - End --->
