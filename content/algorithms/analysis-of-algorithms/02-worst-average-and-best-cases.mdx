---
sidebar_label: Worst, Average and Best Cases
---

# Worst, Average and Best Cases

<!--- Import Component Here --->

import NoContentHere from '@site/src/components/MDX/NoContentHere';
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<!--- Content - Start --->

## AlgoritmalarÄ±n KarmaÅŸÄ±klÄ±k Analizlerinde PopÃ¼ler Notasyonlar

[Ã–nceki yazÄ±mÄ±zda](https://bb-tr-kaynak.netlify.app/algorithms/analysis-of-algorithms/asymptotic-analysis) asimptotik analizin algoritma analizinde problemlerle nasÄ±l baÅŸa Ã§Ä±ktÄ±ÄŸÄ±nÄ± tartÄ±ÅŸmÄ±ktÄ±k. Åimdi ÅŸu konulara gÃ¶z atalÄ±m:

- Asimptotik analizin genel gÃ¶rÃ¼nÃ¼mÃ¼ne
- Worst case (en kÃ¶tÃ¼ durum),
- Average case (ortalama durum),
- Best case (en iyi durum)

### ğŸ‘‰ Big O Notasyonu (Big-O Notation)

**Big-O notasyon**; bir algoritmanÄ±n zaman karmaÅŸÄ±klÄ±ÄŸÄ±nÄ±n en kÃ¶tÃ¼ durumudur (worst case). Big-O notasyon, bir metodun farklÄ± veri boyutu giriÅŸlerinde yavaÅŸ bir oranda iÅŸlenmesini ifade eder. Bir algoritmanÄ±n giriÅŸ deÄŸerlerinin ihtiyaÃ§ duyduÄŸu maximum zaman maliyetidir.

### ğŸ‘‰ Omega Notasyonu (Omega Notation) (ğ®)

Bir algoritmanÄ±n zaman karmaÅŸÄ±klÄ±ÄŸÄ±nÄ±n en iyi durumudur (best case). Big-O notasyonunun tam tersidir. Yani, **Omega notasyonu** bir metodun farklÄ± veri boyutu giriÅŸlerinde hÄ±zlÄ± bir oranda iÅŸlenmesini ifade eder. Bir algoritmanÄ±n giriÅŸ deÄŸerlerinin ihtiyaÃ§ duyduÄŸu minimum zaman maliyetidir.

### ğŸ‘‰ Teta Notasyonu (Theta Notation) (Î¸)

Bir algoritmanÄ±n zaman karmaÅŸÄ±klÄ±ÄŸÄ±nÄ±n ortalama durumudur (average case). Bir fonksiyon Big-O notasyonunun ve Omega notasyonunun ortalama durumudur.

## Bir AlgoritmanÄ±n KarmaÅŸÄ±klÄ±ÄŸÄ±nÄ± (Complexity) Ã–lÃ§mek

YukarÄ±da bahsedilen notasyonlara dayanarak, bir algoritmanÄ±n Ã¼Ã§ tane analiz durumunun olduÄŸunu sÃ¶yleyebiliriz.

### ğŸ‘‰ En KÃ¶tÃ¼ Durum (Worst Case) Analizi (En Ã‡ok KullanÄ±lÄ±r)

**En kÃ¶tÃ¼ durum (worst case) analizi**nde biz bir algoritmanÄ±n Ã§alÄ±ÅŸma zamanÄ±ndaki (running time) Ã¼st sÄ±nÄ±rÄ±nÄ± (upper bound) hesaplarÄ±z. Bir metodun Ã§ok fazla sayÄ±da yÃ¼rÃ¼tÃ¼lmesindeki nedeni bilmeliyiz.

:::note Ã–rnek

Linerar Search algoritmasÄ± iÃ§in; bir dizide aranan bir elemanÄ±n (x) olmamasÄ± en kÃ¶tÃ¼ durumdur.

SearchElement() adÄ±nda bir fonksiyonumuz olsun. SearchElement() fonksiyonu arr[] dizisinde yer alan ve istenen elemanÄ± bulabilmek iÃ§in dizideki bÃ¼tÃ¼n elemanlarÄ± dolaÅŸÄ±r. AranÄ±lanÄ±lan elemanÄ±n dizide olmamasÄ± bize linear searchâ€™deki zaman karmaÅŸÄ±klÄŸÄ±nÄ±n en kÃ¶tÃ¼ durumunu (worst case) verir. GÃ¶sterimi O(n) ÅŸeklinderir.

:::

### ğŸ‘‰ En Ä°yi Durum (Best Case) Analizi (Ã‡ok Nadir KullanÄ±lÄ±r)

**En iyi durum (best case) analizin**de bir bir algoritmanÄ±n Ã§alÄ±ÅŸma zamanÄ±ndaki alt sÄ±nÄ±rÄ± (lower bound) hesaplarÄ±z. Bir metodun Ã§ok az sayÄ±da yÃ¼rÃ¼tÃ¼lmesindeki nedeni bilmeliyiz. Arama algoritmasÄ±nda en iyi durum arrayâ€™de xâ€™in ilk dizinde olmasÄ±dÄ±r. En iyi durumda iÅŸlemin sayÄ±sÄ± sabittir (nâ€™e baÄŸlÄ± deÄŸildir). BÃ¶ylece en iyi durumdaki zaman karmaÅŸÄ±klÄ±ÄŸÄ±nÄ±n gÃ¶sterimi Î©(1)â€™dir.

### ğŸ‘‰ Ortalama Durum (Average Case) Analizi (Nadiren KullanÄ±lÄ±r)

Ortalama durum (average case) analizinde bÃ¼tÃ¼n olasÄ± giriÅŸleri alÄ±rÄ±z ve bÃ¼tÃ¼n giriÅŸlerin iÅŸleme sÃ¼resini hesaplarÄ±z. Åu ÅŸekildedir:

```jsx {1,4}
ortalama durum = toplam girdi sayÄ±sÄ± / tÃ¼m deÄŸerlerin toplamÄ±

Matematiksel gÃ¶sterimi:
W(n) = (1 + 2 + ... n) / n = n(n+1)/(2n) = (n + 1) / 2
```

Bu iÅŸlemin sonucu ortalama durumun zaman karmaÅŸÄ±klÄ±ÄŸÄ±nÄ± ifade edecektir.

## Genelde Hangi Zaman KarmaÅŸÄ±klÄ±ÄŸÄ± (Time Complexity) KullanÄ±lÄ±r?

AÅŸaÄŸÄ±daki karmaÅŸÄ±k analiz notasyonlarÄ± popÃ¼lerliklerine gÃ¶re sÄ±ralanmÄ±ÅŸtÄ±r.

### 1-En KÃ¶tÃ¼ Durum Analizi

Ã‡oÄŸu zaman algoritmayÄ± analiz ederken algoritmanÄ±n en kÃ¶tÃ¼ durumunu analiz ederiz. En kÃ¶tÃ¼ durum analizinde biz bir algoritmadaki **Ã§alÄ±ÅŸma zamanÄ±nÄ±n en Ã¼st sÄ±rÄ±**na (upper bound) bakarÄ±z. Bu da bize iyi bir bilgi saÄŸlar.

### 2-Ortalama Durum Analizi

Ortalama durum analizi pratik Ã¶lÃ§Ã¼mler yapmak iÃ§in Ã§ok kullanÄ±ÅŸlÄ± deÄŸildir. Nadiren kullanÄ±lÄ±r. Bu analizde bÃ¼tÃ¼n olasÄ± giriÅŸlerin matematiksel daÄŸÄ±lÄ±mÄ± bilmeliyiz.

### 3-En Ä°yi Durum Analizi

En iyi durum analizinde bir algoritmada en kÃ¶tÃ¼ durumda herhangi alt sÄ±nÄ±r (lower bound) garanti etmek bize bir bilgi saÄŸlamaz. Bir algoritmanÄ±n Ã§alÄ±ÅŸmasÄ± yÄ±llar alabilir.

<details>
  <summary>
    <b>Asimptotik Analiz HakkÄ±nda Ä°lginÃ§ Bilgiler</b>
  </summary>
  <div>
    <div>
      BazÄ± algoritmalar iÃ§in bÃ¼tÃ¼n durumlar (en kÃ¶tÃ¼, en iyi, ortalama)
      asimptotik olarak aynÄ±dÄ±r. Yani en kÃ¶tÃ¼ ve en iyi durum yoktur.{' '}
    </div>
    <br />
    <details>
      <summary>Ã–rnek</summary>
      <div>
        Merge Sort algoritmasÄ± bÃ¼tÃ¼n durumlarda Î˜(n log(n)) iÅŸlemlerini yapar.
      </div>
    </details>
    <div>
      BazÄ± algoritmalar iÃ§in bÃ¼tÃ¼n durumlar (en kÃ¶tÃ¼, en iyi, ortalama)
      asimptotik olarak aynÄ±dÄ±r. Yani en kÃ¶tÃ¼ ve en iyi durum yoktur.{' '}
    </div>
    <br />
    <details>
      <summary>Ã–rnek</summary>
      <div>
        Tipik Quik Sort algoritmasÄ±ndaki en kÃ¶tÃ¼sÃ¼ giriÅŸ dizisi daha Ã¶nce
        sÄ±ralandÄ±ÄŸÄ±na meydana gelir ve en iyisi pivot elementler her zaman
        diziyi iki yarÄ±ya bÃ¶ler.
      </div>
    </details>
    <br />
    <details>
      <summary>Ã–rnek</summary>
      <div>
        Insertion Sort algoritmasÄ± iÃ§in en kÃ¶tÃ¼ durum dizideki elemanlar ters
        sÄ±ralandÄ±ÄŸÄ±nda ([5,4,3,2,1]) meydana gelir ve en iyi durum dizideki
        elemanlar tÄ±pkÄ± beklenilen Ã§Ä±ktÄ± gibi ([1,2,3,4,5]) sÄ±ralandÄ±ÄŸÄ±nda
        meydana gelir.
      </div>
    </details>
  </div>
</details>

## KarmaÅŸÄ±klÄ±k Analizi Ä°le Ä°lgili Ã–rnekler

### 1-Linerar Search AlgoritmasÄ±

```mdx-code-block
<Tabs>
<TabItem value="c" label="C" default>
```

```c
#include <stdio.h>

// Linear Search ile bir dizi iÃ§erisinde xâ€™i arayacaÄŸÄ±z
// EÄŸer x varsa indexi dÃ¶nder,
// DeÄŸilse -1 dÃ¶nder

    int search(int arr[], int n, int x)
      {
          int i;

          for (i = 0; i < n; i++) {
              if (arr[i] == x)
                  return i;
          }
          return -1;
      }

    int main()
      {
          int arr[] = { 1, 10, 30, 15 };
          int x = 30;
          int n = sizeof(arr) / sizeof(arr[0]);

          // Fonksiyonu Ã§aÄŸÄ±rdÄ±k
          printf("%d is present at index %d", x,
           search(arr, n, x));

          getchar();
          return 0;
      }
```

```mdx-code-block
</TabItem>
<TabItem value="cpp" label="C++">
```

```cpp
#include <bits/stdc++.h>
using namespace std;

// Linear Search ile bir dizi iÃ§erisinde xâ€™i arayacaÄŸÄ±z
// EÄŸer x varsa indexi dÃ¶nder,
// DeÄŸilse -1 dÃ¶nder

    int search(int arr[], int n, int x)
      {
          int i;

          for (i = 0; i < n; i++) {
              if (arr[i] == x)
                  return i;
          }
          return -1;
      }

    int main()
      {
          int arr[] = { 1, 10, 30, 15 };
          int x = 30;
          int n = sizeof(arr) / sizeof(arr[0]);

          // Fonksiyonu Ã§aÄŸÄ±rÄ±r
          cout << x << " is present at index "
              << search(arr, n, x);

          return 0;
      }
```

```mdx-code-block
</TabItem>
<TabItem value="java" label="Java">
```

```java
public class GFG {

// Linear Search ile bir dizi iÃ§erisinde xâ€™i arayacaÄŸÄ±z
// EÄŸer x varsa indexi dÃ¶nder,
// DeÄŸilse -1 dÃ¶nder

    static int search(int arr[], int n, int x)
      {
        int i;

        for (i = 0; i < n; i++) {
            if (arr[i] == x) {
                return i;
            }
        }
        return -1;
      }

    public static void main(String[] args)
      {
        int arr[] = { 1, 10, 30, 15 };
        int x = 30;
        int n = arr.length;

        // Function call
        System.out.printf("%d is present at index %d", x, search(arr, n, x));
      }
    }
```

```mdx-code-block
</TabItem>
<TabItem value="python" label="Python 3">
```

```python
# Linear Search ile bir dizi iÃ§erisinde xâ€™i arayacaÄŸÄ±z
# EÄŸer x varsa indexi dÃ¶nder,
# DeÄŸilse -1 dÃ¶nder

    def search(arr, x):
        for index, value in enumerate(arr):
            if value == x:
                return index
        return -1


    if __name__ == '__main__':
        arr = [1, 10, 30, 15]
        x = 30

        # Fonksiyonu Ã§aÄŸÄ±rÄ±r
        print(x, "is present at index", search(arr, x))
```

```mdx-code-block
</TabItem>
<TabItem value="javascript" label="Javascript">
```

```javascript
// Linear Search ile bir dizi iÃ§erisinde xâ€™i arayacaÄŸÄ±z
// EÄŸer x varsa indexi dÃ¶nder,
// DeÄŸilse -1 dÃ¶nder

function search(arr, n, x) {
  var i;

  for (i = 0; i < n; i++) {
    if (arr[i] == x) {
      return i;
    }
  }
  return -1;
}

var arr = [1, 10, 30, 15];
var x = 30;
var n = arr.length;

document.write(x + ' is present at index ' + search(arr, n, x));
```

```mdx-code-block
</TabItem>
</Tabs>
```

**Ã‡Ä±ktÄ±**

```
30 is present at index 2
```

### Linear Search AlgoritmasÄ±nÄ±n KarmaÅŸÄ±klÄ±k Analizi

#### En Ä°yi Durum (Best Case)

Bulunmak istenen eleman listenin ilk indeksindeyse bu durum gerÃ§ekleÅŸir. BÃ¶ylece karÅŸÄ±laÅŸtÄ±rma bir kez gerÃ§ekleÅŸir. **O(1)** ile gÃ¶sterilir.

#### Ortalama Durum (Average Case)

Verilen listede bulunmak istenen eleman listenin ortasÄ±ndaysa bu durum gerÃ§ekleÅŸir. **O(n)** ile gÃ¶sterilir.

#### En KÃ¶tÃ¼ Durum (Worst Case)

**O(n)** ÅŸeklinde gÃ¶sterelilir. Åu durumlarda gerÃ§ekleÅŸir:

- Aranacak eleman sonuncu indexâ€™te aranmalÄ±
- Aranacak eleman listede olmamalÄ±

### 2-Bu Ã–rnekte Bir Dizinin UzunluÄŸunu AlacaÄŸÄ±z ve AÅŸaÄŸÄ±daki Durumlarla Ä°lgileneceÄŸiz:

- EÄŸer (n) Ã§ift ise Ã§Ä±ktÄ±sÄ± 0â€™dÄ±r.
- EÄŸer (n) tek ise dizideki elemanlarÄ± toplayacaÄŸÄ±z

YukarÄ±da saydÄ±ÄŸÄ±mÄ±z iki madde iÃ§in aÅŸaÄŸÄ±da bir Ã¶rnek yer almaktadÄ±r:

```mdx-code-block
<Tabs>
<TabItem value="cpp" label="C++" default>
```

```cpp
#include <bits/stdc++.h>
using namespace std;

    int getSum(int arr[], int n)
      {
          if (n % 2 == 0) // (n) Ã§ifttir
            {
              return 0;
            }

          int sum = 0;

          for (int i = 0; i < n; i++) {
              sum += arr[i];
          }
          return sum; // (n) tektir
      }

    int main()
    {
        // Biri tek, diÄŸeri Ã§ift uzunlukta olmak Ã¼zere iki dizi bildirildi
        int arr[4] = { 1, 2, 3, 4 };
        int a[5] = { 1, 2, 3, 4, 5 };

        // Fonksiyon Ã§aÄŸrÄ±ldÄ±
        cout << getSum(arr, 4)
            << endl; // Ã‡Ä±ktÄ± 0â€™dÄ±r. Ã‡Ã¼nkÃ¼ (n) Ã§ifttir.
        cout << getSum(a, 5)
            << endl; // Ã‡Ä±ktÄ± sayÄ±larÄ±n toplamÄ±dÄ±r. Ã‡Ã¼nkÃ¼ (n) tektir
    }
```

```mdx-code-block
</TabItem>
<TabItem value="java" label="Java">
```

```java
  public class GFG {
      static int getsum(int arr[], int n)
      {
          if (n % 2 == 0) // eÄŸer (n) Ã§ift ise
            {
              return 0;
            }

          int sum = 0;

          for (int i = 0; i < n; i++)
          {
            sum += arr[i];
          }
          return sum; // eÄŸer (n) tek ise
      }

    public static void main(String[] args)
      {
          int arr1[] = { 1, 2, 3, 4 }; // Ã‡ift uzunlukta bir array tanÄ±mlandÄ±
          int n1 = arr1.length;

          int arr2[] = { 1, 2, 3, 4, 5 }; // Tek uzunlukta bir array tanÄ±mlandÄ±
          int n2 = arr2.length;

          // Function call
          System.out.println(getsum(arr1, n1)); // Ã‡Ä±ktÄ± 0â€™dÄ±r. Ã‡Ã¼nkÃ¼ (n) Ã§ifttir
          System.out.println(getsum(arr2, n2)); // Ã‡Ä±ktÄ± sayÄ±larÄ±n toplamÄ±dÄ±r. Ã‡Ã¼nkÃ¼ (n) tektir
      }
  }
```

```mdx-code-block
</TabItem>
<TabItem value="python" label="Python 3">
```

```python
    def getsum(arr, n):
        if n % 2 == 0:  # eÄŸer (n) Ã§ift ise
            return 0

        Sum = 0
        for i in range(n):
            Sum += arr[i]
        return Sum  # eÄŸer (n) tek ise


        # Drivers Code
        if __name__ == '__main__':
        arr1 = [1, 2, 3, 4]  # Ã‡ift uzunlukta bir array tanÄ±mlandÄ±
        n1 = len(arr1)
        arr2 = [1, 2, 3, 4, 5]  # Tek uzunlukta bir array tanÄ±mlandÄ±
        n2 = len(arr2)

        # Function call
        print(getsum(arr1, n1))  # Ã‡Ä±ktÄ± 0â€™dÄ±r. Ã‡Ã¼nkÃ¼ (n) Ã§ifttir

        print(getsum(arr2, n2))  # Ã‡Ä±ktÄ± sayÄ±larÄ±n toplamÄ±dÄ±r. Ã‡Ã¼nkÃ¼ (n) tektir
```

```mdx-code-block
</TabItem>
</Tabs>
```

**Ã‡Ä±ktÄ±**

```
0
15
```

### Bu Ã–rneÄŸin Zaman KarmaÅŸÄ±klÄ±ÄŸÄ± Analizi

#### En Ä°yi Durum (Best Case)

BÃ¼yÃ¼me eÄŸrisi sabit olacaktÄ±r Ã§Ã¼nkÃ¼ biz en iyi durumda (n)â€™in Ã§ift olduÄŸunu varsayarÄ±z.

#### Ortalama Durum (Average Case)

Bu durumda, Ã§ift ve tek olma ihtimalinin eÅŸit olmasÄ±nÄ± varsayarÄ±z. Bu yÃ¼zden bÃ¼yÃ¼me eÄŸrisi linear olacaktÄ±r.

#### En KÃ¶tÃ¼ Durum (Worst Case)

BÃ¼yÃ¼me eÄŸrisi linear olacaktÄ±r Ã§Ã¼nkÃ¼ (n)â€™in her zaman tek olduÄŸunu varsayarÄ±z.

<!---
You can delete (NoContentHere)
-->

<!---<NoContentHere URL="https://github.com/Fire-Oceann/BB-TR-Kaynak/issues/34" />-->

<!--- Content - End --->

<!--- Links Source - Start --->

## Kaynaklar Baglantisi

:::info Kaynaklar BaÄŸlantÄ±sÄ±

<Tabs>
  <TabItem value="blog-article" label="Blog & Makale">
    <ul>
      <li>
        <a href="https://www.geeksforgeeks.org/analysis-of-algorithms-set-2-asymptotic-analysis/">
          Analysis of Algorithms | Set 2 (Worst, Average and Best Cases)
        </a>
      </li>
    </ul>
  </TabItem>
</Tabs>

:::

<!--- Links Source - End --->
